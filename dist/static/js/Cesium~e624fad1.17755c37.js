(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["Cesium~e624fad1"],{"0768":function(e,n,t){"use strict";n["a"]="varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n#endif\n}\n"},"082a":function(e,n,t){"use strict";var o=t("535a"),i=t("2f63"),a=t("daa2"),r=t("ddf5"),s=t("a24f"),l=t("77d1"),c=t("38d6"),d=t("e349");function u(e,n){if(n=Object(o["a"])(n,o["a"].EMPTY_OBJECT),Object(i["a"])(e)&&Object(c["a"])(e,"KHR_materials_common")){Object(c["a"])(e,"KHR_techniques_webgl")||(Object(i["a"])(e.extensions)||(e.extensions={}),e.extensions.KHR_techniques_webgl={programs:[],shaders:[],techniques:[]},e.extensionsUsed.push("KHR_techniques_webgl"),e.extensionsRequired.push("KHR_techniques_webgl"));var t=e.extensions.KHR_techniques_webgl;_(e);var a=m(e),r=d["a"].splitIncompatibleMaterials(e),s={},u=!1;return l["a"].material(e,(function(o,l){if(Object(i["a"])(o.extensions)&&Object(i["a"])(o.extensions.KHR_materials_common)){var c=o.extensions.KHR_materials_common,d=r[l],m=v(c,d),f=s[m];Object(i["a"])(f)||(f=p(e,t,d,c,a,n.addBatchIdToGeneratedShaders),s[m]=f,u=!0);var _,g={},h=c.values;for(var C in h)h.hasOwnProperty(C)&&"transparent"!==C&&"doubleSided"!==C&&(_="u_"+C.toLowerCase(),g[_]=h[C]);o.extensions.KHR_techniques_webgl={technique:f,values:g},o.alphaMode="OPAQUE",c.transparent&&(o.alphaMode="BLEND"),c.doubleSided&&(o.doubleSided=!0)}})),u?(d["a"].ensureSemanticExistence(e),e):e}}function m(e){var n,t={};if(Object(i["a"])(e.extensions)&&Object(i["a"])(e.extensions.KHR_materials_common)&&(n=e.extensions.KHR_materials_common.lights),Object(i["a"])(n)){var o=e.nodes;for(var r in o)if(o.hasOwnProperty(r)){var s=o[r];if(Object(i["a"])(s.extensions)&&Object(i["a"])(s.extensions.KHR_materials_common)){var l=s.extensions.KHR_materials_common.light;Object(i["a"])(l)&&Object(i["a"])(n[l])&&(n[l].node=r),delete s.extensions.KHR_materials_common}}var c=0;for(var d in n)if(n.hasOwnProperty(d)){var u=n[d],m=u.type;if("ambient"!==m&&!Object(i["a"])(u.node)){delete n[d];continue}var p="light"+c.toString();switch(u.baseName=p,m){case"ambient":var f=u.ambient;t[p+"Color"]={type:a["a"].FLOAT_VEC3,value:f.color};break;case"directional":var v=u.directional;t[p+"Color"]={type:a["a"].FLOAT_VEC3,value:v.color},Object(i["a"])(u.node)&&(t[p+"Transform"]={node:u.node,semantic:"MODELVIEW",type:a["a"].FLOAT_MAT4});break;case"point":var _=u.point;t[p+"Color"]={type:a["a"].FLOAT_VEC3,value:_.color},Object(i["a"])(u.node)&&(t[p+"Transform"]={node:u.node,semantic:"MODELVIEW",type:a["a"].FLOAT_MAT4}),t[p+"Attenuation"]={type:a["a"].FLOAT_VEC3,value:[_.constantAttenuation,_.linearAttenuation,_.quadraticAttenuation]};break;case"spot":var g=u.spot;t[p+"Color"]={type:a["a"].FLOAT_VEC3,value:g.color},Object(i["a"])(u.node)&&(t[p+"Transform"]={node:u.node,semantic:"MODELVIEW",type:a["a"].FLOAT_MAT4},t[p+"InverseTransform"]={node:u.node,semantic:"MODELVIEWINVERSE",type:a["a"].FLOAT_MAT4,useInFragment:!0}),t[p+"Attenuation"]={type:a["a"].FLOAT_VEC3,value:[g.constantAttenuation,g.linearAttenuation,g.quadraticAttenuation]},t[p+"FallOff"]={type:a["a"].FLOAT_VEC2,value:[g.fallOffAngle,g.fallOffExponent]};break}++c}}return t}function p(e,n,t,l,d,u){Object(i["a"])(l)||(l={}),u=Object(o["a"])(u,!1);var m,p=n.techniques,v=n.shaders,_=n.programs,g=l.technique.toUpperCase();Object(i["a"])(e.extensions)&&Object(i["a"])(e.extensions.KHR_materials_common)&&(m=e.extensions.KHR_materials_common.lights);var h,C=l.values,b=Object(o["a"])(l.jointCount,0),T=!1,x=!1;Object(i["a"])(t)&&(h=t.skinning,T=h.skinned,x=t.hasVertexColors);var E,y="precision highp float;\n",O="precision highp float;\n",S="CONSTANT"!==g,I={u_modelViewMatrix:{semantic:Object(c["a"])(e,"CESIUM_RTC")?"CESIUM_RTC_MODELVIEW":"MODELVIEW",type:a["a"].FLOAT_MAT4},u_projectionMatrix:{semantic:"PROJECTION",type:a["a"].FLOAT_MAT4}};S&&(I.u_normalMatrix={semantic:"MODELVIEWINVERSETRANSPOSE",type:a["a"].FLOAT_MAT3}),T&&(I.u_jointMatrix={count:b,semantic:"JOINTMATRIX",type:a["a"].FLOAT_MAT4});var D=!1;for(var F in C)if(C.hasOwnProperty(F)&&"transparent"!==F&&"doubleSided"!==F){var A=f(F,C[F]);E="u_"+F.toLowerCase(),D||A!==a["a"].SAMPLER_2D||(D=!0),I[E]={type:A}}if(Object(i["a"])(I.u_diffuse)&&(I.u_diffuse.semantic="_3DTILESDIFFUSE"),Object(i["a"])(d))for(var z in d)d.hasOwnProperty(z)&&(E="u_"+z,I[E]=d[z]);for(E in I)if(I.hasOwnProperty(E)){var H=I[E],L=Object(i["a"])(H.count)?"["+H.count+"]":"";H.type!==a["a"].FLOAT_MAT3&&H.type!==a["a"].FLOAT_MAT4||H.useInFragment?(O+="uniform "+Object(r["a"])(H.type)+" "+E+L+";\n",delete H.useInFragment):y+="uniform "+Object(r["a"])(H.type)+" "+E+L+";\n"}var R="";T&&(R+="    mat4 skinMatrix =\n        a_weight.x * u_jointMatrix[int(a_joint.x)] +\n        a_weight.y * u_jointMatrix[int(a_joint.y)] +\n        a_weight.z * u_jointMatrix[int(a_joint.z)] +\n        a_weight.w * u_jointMatrix[int(a_joint.w)];\n");var w,j={a_position:{semantic:"POSITION"}};y+="attribute vec3 a_position;\n",y+="varying vec3 v_positionEC;\n",R+=T?"  vec4 pos = u_modelViewMatrix * skinMatrix * vec4(a_position,1.0);\n":"  vec4 pos = u_modelViewMatrix * vec4(a_position,1.0);\n",R+="  v_positionEC = pos.xyz;\n",R+="  gl_Position = u_projectionMatrix * pos;\n",O+="varying vec3 v_positionEC;\n",S&&(j.a_normal={semantic:"NORMAL"},y+="attribute vec3 a_normal;\n",y+="varying vec3 v_normal;\n",R+=T?"  v_normal = u_normalMatrix * mat3(skinMatrix) * a_normal;\n":"  v_normal = u_normalMatrix * a_normal;\n",O+="varying vec3 v_normal;\n"),D&&(j.a_texcoord_0={semantic:"TEXCOORD_0"},w="v_texcoord_0",y+="attribute vec2 a_texcoord_0;\n",y+="varying vec2 "+w+";\n",R+="  "+w+" = a_texcoord_0;\n",O+="varying vec2 "+w+";\n"),T&&(j.a_joint={semantic:"JOINTS_0"},j.a_weight={semantic:"WEIGHTS_0"},y+="attribute vec4 a_joint;\n",y+="attribute vec4 a_weight;\n"),x&&(j.a_vertexColor={semantic:"COLOR_0"},y+="attribute vec4 a_vertexColor;\n",y+="varying vec4 v_vertexColor;\n",R+="  v_vertexColor = a_vertexColor;\n",O+="varying vec4 v_vertexColor;\n"),u&&(j.a_batchId={semantic:"_BATCHID"},y+="attribute float a_batchId;\n");var M=S&&("BLINN"===g||"PHONG"===g)&&Object(i["a"])(I.u_specular)&&Object(i["a"])(I.u_shininess)&&I.u_shininess>0,N=!1,P=!1,G="";for(var V in m)if(m.hasOwnProperty(V)){var B=m[V],W=B.type.toLowerCase(),k=B.baseName;G+="  {\n";var U,q,K="u_"+k+"Color";"ambient"===W?(P=!0,G+="    ambientLight += "+K+";\n"):S&&(N=!0,U="v_"+k+"Direction",q="v_"+k+"Position","point"!==W&&(y+="varying vec3 "+U+";\n",O+="varying vec3 "+U+";\n",R+="  "+U+" = mat3(u_"+k+"Transform) * vec3(0.,0.,1.);\n","directional"===W&&(G+="    vec3 l = normalize("+U+");\n")),"directional"!==W?(y+="varying vec3 "+q+";\n",O+="varying vec3 "+q+";\n",R+="  "+q+" = u_"+k+"Transform[3].xyz;\n",G+="    vec3 VP = "+q+" - v_positionEC;\n",G+="    vec3 l = normalize(VP);\n",G+="    float range = length(VP);\n",G+="    float attenuation = 1.0 / (u_"+k+"Attenuation.x + ",G+="(u_"+k+"Attenuation.y * range) + ",G+="(u_"+k+"Attenuation.z * range * range));\n"):G+="    float attenuation = 1.0;\n","spot"===W&&(G+="    float spotDot = dot(l, normalize("+U+"));\n",G+="    if (spotDot < cos(u_"+k+"FallOff.x * 0.5))\n",G+="    {\n",G+="      attenuation = 0.0;\n",G+="    }\n",G+="    else\n",G+="    {\n",G+="        attenuation *= max(0.0, pow(spotDot, u_"+k+"FallOff.y));\n",G+="    }\n"),G+="    diffuseLight += "+K+"* max(dot(normal,l), 0.) * attenuation;\n",M&&("BLINN"===g?(G+="    vec3 h = normalize(l + viewDir);\n",G+="    float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess)) * attenuation;\n"):(G+="    vec3 reflectDir = reflect(-l, normal);\n",G+="    float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess)) * attenuation;\n"),G+="    specularLight += "+K+" * specularIntensity;\n")),G+="  }\n"}if(P||(G+="  ambientLight += vec3(0.2, 0.2, 0.2);\n"),!N&&"CONSTANT"!==g){O+="#ifdef USE_CUSTOM_LIGHT_COLOR \n",O+="uniform vec3 gltf_lightColor; \n",O+="#endif \n",G+="#ifndef USE_CUSTOM_LIGHT_COLOR \n",G+="    vec3 lightColor = czm_lightColor;\n",G+="#else \n",G+="    vec3 lightColor = gltf_lightColor;\n",G+="#endif \n",G+="  vec3 l = normalize(czm_lightDirectionEC);\n";var X="0.2";G+="  diffuseLight += lightColor * max(dot(normal,l), "+X+");\n",M&&("BLINN"===g?(G+="  vec3 h = normalize(l + viewDir);\n",G+="  float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess));\n"):(G+="  vec3 reflectDir = reflect(-l, normal);\n",G+="  float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess));\n"),G+="  specularLight += lightColor * specularIntensity;\n")}y+="void main(void) {\n",y+=R,y+="}\n",O+="void main(void) {\n";var Y,J="  vec3 color = vec3(0.0, 0.0, 0.0);\n";S&&(O+="  vec3 normal = normalize(v_normal);\n",l.doubleSided&&(O+="  if (czm_backFacing())\n",O+="  {\n",O+="    normal = -normal;\n",O+="  }\n")),"CONSTANT"!==g?(Object(i["a"])(I.u_diffuse)&&(I.u_diffuse.type===a["a"].SAMPLER_2D?O+="  vec4 diffuse = texture2D(u_diffuse, "+w+");\n":O+="  vec4 diffuse = u_diffuse;\n",O+="  vec3 diffuseLight = vec3(0.0, 0.0, 0.0);\n",J+="  color += diffuse.rgb * diffuseLight;\n"),M&&(I.u_specular.type===a["a"].SAMPLER_2D?O+="  vec3 specular = texture2D(u_specular, "+w+").rgb;\n":O+="  vec3 specular = u_specular.rgb;\n",O+="  vec3 specularLight = vec3(0.0, 0.0, 0.0);\n",J+="  color += specular * specularLight;\n"),Y=Object(i["a"])(I.u_transparency)?"  gl_FragColor = vec4(color * diffuse.a * u_transparency, diffuse.a * u_transparency);\n":"  gl_FragColor = vec4(color * diffuse.a, diffuse.a);\n"):Y=Object(i["a"])(I.u_transparency)?"  gl_FragColor = vec4(color * u_transparency, u_transparency);\n":"  gl_FragColor = vec4(color, 1.0);\n",x&&(J+="  color *= v_vertexColor.rgb;\n"),Object(i["a"])(I.u_emission)&&(I.u_emission.type===a["a"].SAMPLER_2D?O+="  vec3 emission = texture2D(u_emission, "+w+").rgb;\n":O+="  vec3 emission = u_emission.rgb;\n",J+="  color += emission;\n"),(Object(i["a"])(I.u_ambient)||"CONSTANT"!==g)&&(Object(i["a"])(I.u_ambient)?I.u_ambient.type===a["a"].SAMPLER_2D?O+="  vec3 ambient = texture2D(u_ambient, "+w+").rgb;\n":O+="  vec3 ambient = u_ambient.rgb;\n":O+="  vec3 ambient = diffuse.rgb;\n",J+="  color += ambient * ambientLight;\n"),O+="  vec3 viewDir = -normalize(v_positionEC);\n",O+="  vec3 ambientLight = vec3(0.0, 0.0, 0.0);\n",O+=G,O+=J,O+=Y,O+="}\n";var Z=Object(s["a"])(v,{type:a["a"].VERTEX_SHADER,extras:{_pipeline:{source:y,extension:".glsl"}}}),Q=Object(s["a"])(v,{type:a["a"].FRAGMENT_SHADER,extras:{_pipeline:{source:O,extension:".glsl"}}}),$=Object(s["a"])(_,{fragmentShader:Q,vertexShader:Z}),ee=Object(s["a"])(p,{attributes:j,program:$,uniforms:I});return ee}function f(e,n){var t;switch(t=Object(i["a"])(n.value)?n.value:Object(i["a"])(n.index)?[n.index]:n,e){case"ambient":return 1===t.length?a["a"].SAMPLER_2D:a["a"].FLOAT_VEC4;case"diffuse":return 1===t.length?a["a"].SAMPLER_2D:a["a"].FLOAT_VEC4;case"emission":return 1===t.length?a["a"].SAMPLER_2D:a["a"].FLOAT_VEC4;case"specular":return 1===t.length?a["a"].SAMPLER_2D:a["a"].FLOAT_VEC4;case"shininess":return a["a"].FLOAT;case"transparency":return a["a"].FLOAT;case"transparent":return a["a"].BOOL;case"doubleSided":return a["a"].BOOL}}function v(e,n){var t="";t+="technique:"+e.technique+";";for(var a=e.values,r=Object.keys(a).sort(),s=r.length,l=0;l<s;++l){var c=r[l];a.hasOwnProperty(c)&&(t+=c+":"+f(c,a[c]),t+=";")}var d=Object(o["a"])(e.jointCount,0);if(t+=d.toString()+";",Object(i["a"])(n)){var u=n.skinning;d>0&&(t+=u.type+";"),t+=n.hasVertexColors}return t}function _(e){var n=e.extensions.KHR_materials_common;if(Object(i["a"])(n)&&Object(i["a"])(n.lights))for(var t=n.lights,a=t.length,r=0;r<a;r++){var s=t[r];if("ambient"===s.type){Object(i["a"])(s.ambient)||(s.ambient={});var l=s.ambient;Object(i["a"])(l.color)||(l.color=[1,1,1])}else if("directional"===s.type){Object(i["a"])(s.directional)||(s.directional={});var c=s.directional;Object(i["a"])(c.color)||(c.color=[1,1,1])}else if("point"===s.type){Object(i["a"])(s.point)||(s.point={});var d=s.point;Object(i["a"])(d.color)||(d.color=[1,1,1]),d.constantAttenuation=Object(o["a"])(d.constantAttenuation,1),d.linearAttenuation=Object(o["a"])(d.linearAttenuation,0),d.quadraticAttenuation=Object(o["a"])(d.quadraticAttenuation,0)}else if("spot"===s.type){Object(i["a"])(s.spot)||(s.spot={});var u=s.spot;Object(i["a"])(u.color)||(u.color=[1,1,1]),u.constantAttenuation=Object(o["a"])(u.constantAttenuation,1),u.fallOffAngle=Object(o["a"])(u.fallOffAngle,3.14159265),u.fallOffExponent=Object(o["a"])(u.fallOffExponent,0),u.linearAttenuation=Object(o["a"])(u.linearAttenuation,0),u.quadraticAttenuation=Object(o["a"])(u.quadraticAttenuation,0)}}}n["a"]=u},"2c4b":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec4 color;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"2d11":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"365a":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_st = st;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"461c":function(e,n,t){"use strict";n["a"]="#ifdef MRT\n#extension GL_EXT_draw_buffers : enable\n#endif\n\nuniform vec4 u_bgColor;\nuniform sampler2D u_depthTexture;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    if (texture2D(u_depthTexture, v_textureCoordinates).r < 1.0)\n    {\n#ifdef MRT\n        gl_FragData[0] = u_bgColor;\n        gl_FragData[1] = vec4(u_bgColor.a);\n#else\n        gl_FragColor = u_bgColor;\n#endif\n        return;\n    }\n    \n    discard;\n}\n"},"60fc":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec3 tangent;\nattribute vec3 bitangent;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_tangentEC;\nvarying vec3 v_bitangentEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_tangentEC = czm_normal * tangent;                       // tangent in eye coordinates\n    v_bitangentEC = czm_normal * bitangent;                   // bitangent in eye coordinates\n    v_st = st;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"6d53":function(e,n,t){"use strict";n["a"]='#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform sampler2D u_atlas;\n\n#ifdef VECTOR_TILE\nuniform vec4 u_highlightColor;\n#endif\n\nvarying vec2 v_textureCoordinates;\nvarying vec4 v_pickColor;\nvarying vec4 v_color;\n\n#ifdef SDF\nvarying vec4 v_outlineColor;\nvarying float v_outlineWidth;\n#endif\n\n#ifdef FRAGMENT_DEPTH_CHECK\nvarying vec4 v_textureCoordinateBounds;                  // the min and max x and y values for the texture coordinates\nvarying vec4 v_originTextureCoordinateAndTranslate;      // texture coordinate at the origin, billboard translate (used for label glyphs)\nvarying vec4 v_compressed;                               // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize\nvarying mat2 v_rotationMatrix;\n\nconst float SHIFT_LEFT12 = 4096.0;\nconst float SHIFT_LEFT1 = 2.0;\n\nconst float SHIFT_RIGHT12 = 1.0 / 4096.0;\nconst float SHIFT_RIGHT1 = 1.0 / 2.0;\n\nfloat getGlobeDepth(vec2 adjustedST, vec2 depthLookupST, bool applyTranslate, vec2 dimensions, vec2 imageSize)\n{\n    vec2 lookupVector = imageSize * (depthLookupST - adjustedST);\n    lookupVector = v_rotationMatrix * lookupVector;\n    vec2 labelOffset = (dimensions - imageSize) * (depthLookupST - vec2(0.0, v_originTextureCoordinateAndTranslate.y)); // aligns label glyph with bounding rectangle.  Will be zero for billboards because dimensions and imageSize will be equal\n\n    vec2 translation = v_originTextureCoordinateAndTranslate.zw;\n\n    if (applyTranslate)\n    {\n        // this is only needed for labels where the horizontal origin is not LEFT\n        // it moves the label back to where the "origin" should be since all label glyphs are set to HorizontalOrigin.LEFT\n        translation += (dimensions * v_originTextureCoordinateAndTranslate.xy * vec2(1.0, 0.0));\n    }\n\n    vec2 st = ((lookupVector - translation + labelOffset) + gl_FragCoord.xy) / czm_viewport.zw;\n    float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, st));\n\n    if (logDepthOrDepth == 0.0)\n    {\n        return 0.0; // not on the globe\n    }\n\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n    return eyeCoordinate.z / eyeCoordinate.w;\n}\n#endif\n\n\n#ifdef SDF\n\n// Get the distance from the edge of a glyph at a given position sampling an SDF texture.\nfloat getDistance(vec2 position)\n{\n    return texture2D(u_atlas, position).r;\n}\n\n// Samples the sdf texture at the given position and produces a color based on the fill color and the outline.\nvec4 getSDFColor(vec2 position, float outlineWidth, vec4 outlineColor, float smoothing)\n{\n    float distance = getDistance(position);\n\n    if (outlineWidth > 0.0)\n    {\n        // Don\'t get the outline edge exceed the SDF_EDGE\n        float outlineEdge = clamp(SDF_EDGE - outlineWidth, 0.0, SDF_EDGE);\n        float outlineFactor = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);\n        vec4 sdfColor = mix(outlineColor, v_color, outlineFactor);\n        float alpha = smoothstep(outlineEdge - smoothing, outlineEdge + smoothing, distance);\n        return vec4(sdfColor.rgb, sdfColor.a * alpha);\n    }\n    else\n    {\n        float alpha = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);\n        return vec4(v_color.rgb, v_color.a * alpha);\n    }\n}\n#endif\n\nvoid main()\n{\n    vec4 color = texture2D(u_atlas, v_textureCoordinates);\n\n#ifdef SDF\n    float outlineWidth = v_outlineWidth;\n    vec4 outlineColor = v_outlineColor;\n\n    // Get the current distance\n    float distance = getDistance(v_textureCoordinates);\n\n#ifdef GL_OES_standard_derivatives\n    float smoothing = fwidth(distance);\n    // Get an offset that is approximately half the distance to the neighbor pixels\n    // 0.354 is approximately half of 1/sqrt(2)\n    vec2 sampleOffset = 0.354 * vec2(dFdx(v_textureCoordinates) + dFdy(v_textureCoordinates));\n\n    // Sample the center point\n    vec4 center = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);\n\n    // Sample the 4 neighbors\n    vec4 color1 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);\n    vec4 color2 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);\n    vec4 color3 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);\n    vec4 color4 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);\n\n    // Equally weight the center sample and the 4 neighboring samples\n    color = (center + color1 + color2 + color3 + color4)/5.0;\n#else\n    // Just do a single sample\n    float smoothing = 1.0/32.0;\n    color = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);\n#endif\n\n    color = czm_gammaCorrect(color);\n#else\n    color = czm_gammaCorrect(color);\n    color *= czm_gammaCorrect(v_color);\n#endif\n\n// Fully transparent parts of the billboard are not pickable.\n#if !defined(OPAQUE) && !defined(TRANSLUCENT)\n    if (color.a < 0.005)   // matches 0/255 and 1/255\n    {\n        discard;\n    }\n#else\n// The billboard is rendered twice. The opaque pass discards translucent fragments\n// and the translucent pass discards opaque fragments.\n#ifdef OPAQUE\n    if (color.a < 0.995)   // matches < 254/255\n    {\n        discard;\n    }\n#else\n    if (color.a >= 0.995)  // matches 254/255 and 255/255\n    {\n        discard;\n    }\n#endif\n#endif\n\n#ifdef VECTOR_TILE\n    color *= u_highlightColor;\n#endif\n    gl_FragColor = color;\n\n#ifdef LOG_DEPTH\n    czm_writeLogDepth();\n#endif\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    float temp = v_compressed.y;\n\n    temp = temp * SHIFT_RIGHT1;\n\n    float temp2 = (temp - floor(temp)) * SHIFT_LEFT1;\n    bool enableDepthTest = temp2 != 0.0;\n    bool applyTranslate = floor(temp) != 0.0;\n\n    if (enableDepthTest) {\n        temp = v_compressed.z;\n        temp = temp * SHIFT_RIGHT12;\n\n        vec2 dimensions;\n        dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;\n        dimensions.x = floor(temp);\n\n        temp = v_compressed.w;\n        temp = temp * SHIFT_RIGHT12;\n\n        vec2 imageSize;\n        imageSize.y = (temp - floor(temp)) * SHIFT_LEFT12;\n        imageSize.x = floor(temp);\n\n        vec2 adjustedST = v_textureCoordinates - v_textureCoordinateBounds.xy;\n        adjustedST = adjustedST / vec2(v_textureCoordinateBounds.z - v_textureCoordinateBounds.x, v_textureCoordinateBounds.w - v_textureCoordinateBounds.y);\n\n        float epsilonEyeDepth = v_compressed.x + czm_epsilon1;\n        float globeDepth1 = getGlobeDepth(adjustedST, v_originTextureCoordinateAndTranslate.xy, applyTranslate, dimensions, imageSize);\n\n        // negative values go into the screen\n        if (globeDepth1 != 0.0 && globeDepth1 > epsilonEyeDepth)\n        {\n            float globeDepth2 = getGlobeDepth(adjustedST, vec2(0.0, 1.0), applyTranslate, dimensions, imageSize); // top left corner\n            if (globeDepth2 != 0.0 && globeDepth2 > epsilonEyeDepth)\n            {\n                float globeDepth3 = getGlobeDepth(adjustedST, vec2(1.0, 1.0), applyTranslate, dimensions, imageSize); // top right corner\n                if (globeDepth3 != 0.0 && globeDepth3 > epsilonEyeDepth)\n                {\n                    discard;\n                }\n            }\n        }\n    }\n#endif\n\n}\n'},"7be3":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec2 expandAndWidth;\nattribute vec2 st;\nattribute float batchId;\n\nvarying float v_width;\nvarying vec2 v_st;\nvarying float v_polylineAngle;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n    v_width = width;\n    v_st.s = st.s;\n    v_st.t = czm_writeNonPerspective(st.t, gl_Position.w);\n    v_polylineAngle = angle;\n}\n"},"9c89":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec4 color;\nattribute float batchId;\n\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"9ffa":function(e,n,t){"use strict";n["a"]="varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n#endif\n}\n"},a0fe:function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec2 expandAndWidth;\nattribute vec4 color;\nattribute float batchId;\n\nvarying vec4 v_color;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n    v_color = color;\n}\n"},b6b6:function(e,n,t){"use strict";n["a"]="varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_tangentEC;\nvarying vec3 v_bitangentEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n    mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_bitangentEC);\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = tangentToEyeMatrix;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n#endif\n}\n"},d007:function(e,n,t){"use strict";var o=t("535a"),i=t("2f63"),a=t("daa2"),r=t("ddf5"),s=t("a24f"),l=t("77d1"),c=t("38d6"),d=t("e349");function u(e,n){if(n=Object(o["a"])(n,o["a"].EMPTY_OBJECT),Object(c["a"])(e,"KHR_techniques_webgl"))return e;if(!Object(i["a"])(e.materials)||0===e.materials.length)return e;Object(i["a"])(e.extensions)||(e.extensions={}),Object(i["a"])(e.extensionsUsed)||(e.extensionsUsed=[]),Object(i["a"])(e.extensionsRequired)||(e.extensionsRequired=[]),e.extensions.KHR_techniques_webgl={programs:[],shaders:[],techniques:[]},e.extensionsUsed.push("KHR_techniques_webgl"),e.extensionsRequired.push("KHR_techniques_webgl");var t=d["a"].splitIncompatibleMaterials(e);return l["a"].material(e,(function(o,a){var r={},s=h(e,o,a,r,t,n);Object(i["a"])(o.extensions)||(o.extensions={}),o.extensions.KHR_techniques_webgl={values:r,technique:s}})),d["a"].ensureSemanticExistence(e),e}function m(e){return Object(i["a"])(e.extensions)&&Object(i["a"])(e.extensions.KHR_materials_pbrSpecularGlossiness)}function p(e,n,t,o,a){var r,s=t[n];return Object(i["a"])(s)&&Object(i["a"])(s.texCoord)&&1===s.texCoord&&(o=o.replace("0","1")),Object(i["a"])(t[n+"Offset"])?(r=n+"Coord",a.fragmentShaderMain+="    vec2 "+r+" = computeTexCoord("+o+", "+n+"Offset, "+n+"Rotation, "+n+"Scale);\n"):r=o,r}var f=[0,0],v=[0],_=[1,1];function g(e,n,t){if(-1!==e.indexOf("Texture")&&Object(i["a"])(n.extensions)&&Object(i["a"])(n.extensions.KHR_texture_transform)){var a="u_"+e,r=n.extensions.KHR_texture_transform;t[a+"Offset"]=Object(o["a"])(r.offset,f),t[a+"Rotation"]=Object(o["a"])(r.rotation,v),t[a+"Scale"]=Object(o["a"])(r.scale,_),Object(i["a"])(n.texCoord)&&Object(i["a"])(r.texCoord)&&(t[a].texCoord=r.texCoord)}}function h(e,n,t,d,u,f){var v,_,h,b=Object(o["a"])(f.addBatchIdToGeneratedShaders,!1),T=e.extensions.KHR_techniques_webgl,x=T.techniques,E=T.shaders,y=T.programs,O=m(n),S=n.pbrMetallicRoughness;if(Object(i["a"])(S)&&!O)for(_ in S)S.hasOwnProperty(_)&&(h=S[_],v="u_"+_,d[v]=h,g(_,h,d));if(O){var I=n.extensions.KHR_materials_pbrSpecularGlossiness;for(_ in I)I.hasOwnProperty(_)&&(h=I[_],v="u_"+_,d[v]=h,g(_,h,d))}for(var D in n)n.hasOwnProperty(D)&&(D.indexOf("Texture")>=0||D.indexOf("Factor")>=0)&&(h=n[D],v="u_"+D,d[v]=h,g(D,h,d));var F,A="precision highp float;\n",z="precision highp float;\n";Object(i["a"])(e.skins)&&(F=e.skins[0]);var H,L,R=Object(i["a"])(F)?F.joints:[],w=R.length,j=u[t],M=!1,N=!1,P=!1,G=!1,V=!1,B=!1,W=!1,k=!1,U=!1;Object(i["a"])(j)&&(H=j.skinning,M=H.skinned&&R.length>0,N=j.hasVertexColors,P=j.hasMorphTargets,G=j.hasNormals,V=j.hasTangents,B=j.hasTexCoords,W=j.hasTexCoord1,k=j.hasOutline),P&&l["a"].mesh(e,(function(e){l["a"].meshPrimitive(e,(function(e){if(e.material===t){var n=e.targets;Object(i["a"])(n)&&(L=n)}}))}));var q={u_modelViewMatrix:{semantic:Object(c["a"])(e,"CESIUM_RTC")?"CESIUM_RTC_MODELVIEW":"MODELVIEW",type:a["a"].FLOAT_MAT4},u_projectionMatrix:{semantic:"PROJECTION",type:a["a"].FLOAT_MAT4}};Object(i["a"])(n.extensions)&&Object(i["a"])(n.extensions.KHR_materials_unlit)&&(U=!0),G&&(q.u_normalMatrix={semantic:"MODELVIEWINVERSETRANSPOSE",type:a["a"].FLOAT_MAT3}),M&&(q.u_jointMatrix={count:w,semantic:"JOINTMATRIX",type:a["a"].FLOAT_MAT4}),P&&(q.u_morphWeights={count:L.length,semantic:"MORPHWEIGHTS",type:a["a"].FLOAT});var K=n.alphaMode;for(v in Object(i["a"])(K)&&"MASK"===K&&(q.u_alphaCutoff={semantic:"ALPHACUTOFF",type:a["a"].FLOAT}),d)d.hasOwnProperty(v)&&(q[v]={type:C(v)});var X=Object(o["a"])(q.u_baseColorTexture,q.u_baseColorFactor);for(v in Object(i["a"])(X)&&(X.semantic="_3DTILESDIFFUSE"),q)if(q.hasOwnProperty(v)){var Y=q[v],J=Object(i["a"])(Y.count)?"["+Y.count+"]":"";Y.type!==a["a"].FLOAT_MAT3&&Y.type!==a["a"].FLOAT_MAT4&&"u_morphWeights"!==v||Y.useInFragment?(z+="uniform "+Object(r["a"])(Y.type)+" "+v+J+";\n",delete Y.useInFragment):A+="uniform "+Object(r["a"])(Y.type)+" "+v+J+";\n"}k&&(z+="uniform sampler2D u_outlineTexture;\n");var Z="";M&&(Z+="    mat4 skinMatrix =\n        a_weight.x * u_jointMatrix[int(a_joint.x)] +\n        a_weight.y * u_jointMatrix[int(a_joint.y)] +\n        a_weight.z * u_jointMatrix[int(a_joint.z)] +\n        a_weight.w * u_jointMatrix[int(a_joint.w)];\n");var Q={a_position:{semantic:"POSITION"}};if(k&&(Q.a_outlineCoordinates={semantic:"_OUTLINE_COORDINATES"}),A+="attribute vec3 a_position;\n",G&&(A+="varying vec3 v_positionEC;\n"),k&&(A+="attribute vec3 a_outlineCoordinates;\n",A+="varying vec3 v_outlineCoordinates;\n"),Z+="    vec3 weightedPosition = a_position;\n",G&&(Z+="    vec3 weightedNormal = a_normal;\n"),V&&(Z+="    vec4 weightedTangent = a_tangent;\n"),P)for(var $=0;$<L.length;$++){var ee=L[$];for(var ne in ee)if(ee.hasOwnProperty(ne)&&"extras"!==ne){var te="a_"+ne+"_"+$;Q[te]={semantic:ne+"_"+$},A+="attribute vec3 "+te+";\n","POSITION"===ne?Z+="    weightedPosition += u_morphWeights["+$+"] * "+te+";\n":"NORMAL"===ne?Z+="    weightedNormal += u_morphWeights["+$+"] * "+te+";\n":V&&"TANGENT"===ne&&(Z+="    weightedTangent.xyz += u_morphWeights["+$+"] * "+te+";\n")}}Z+=M?"    vec4 position = skinMatrix * vec4(weightedPosition, 1.0);\n":"    vec4 position = vec4(weightedPosition, 1.0);\n",Z+="    position = u_modelViewMatrix * position;\n",G&&(Z+="    v_positionEC = position.xyz;\n"),Z+="    gl_Position = u_projectionMatrix * position;\n",k&&(Z+="    v_outlineCoordinates = a_outlineCoordinates;\n"),G&&(Q.a_normal={semantic:"NORMAL"},A+="attribute vec3 a_normal;\n",U||(A+="varying vec3 v_normal;\n",Z+=M?"    v_normal = u_normalMatrix * mat3(skinMatrix) * weightedNormal;\n":"    v_normal = u_normalMatrix * weightedNormal;\n",z+="varying vec3 v_normal;\n"),z+="varying vec3 v_positionEC;\n"),V&&(Q.a_tangent={semantic:"TANGENT"},A+="attribute vec4 a_tangent;\n",A+="varying vec4 v_tangent;\n",Z+="    v_tangent.xyz = u_normalMatrix * weightedTangent.xyz;\n",Z+="    v_tangent.w = weightedTangent.w;\n",z+="varying vec4 v_tangent;\n"),k&&(z+="varying vec3 v_outlineCoordinates;\n");var oe,ie,ae,re,se,le,ce,de,ue="";if(B){if(Q.a_texcoord_0={semantic:"TEXCOORD_0"},oe="v_texcoord_0",A+="attribute vec2 a_texcoord_0;\n",A+="varying vec2 "+oe+";\n",Z+="    "+oe+" = a_texcoord_0;\n",z+="varying vec2 "+oe+";\n",W){Q.a_texcoord_1={semantic:"TEXCOORD_1"};var me=oe.replace("0","1");A+="attribute vec2 a_texcoord_1;\n",A+="varying vec2 "+me+";\n",Z+="    "+me+" = a_texcoord_1;\n",z+="varying vec2 "+me+";\n"}var pe={fragmentShaderMain:ue};ie=p(e,"u_normalTexture",d,oe,pe),ae=p(e,"u_baseColorTexture",d,oe,pe),re=p(e,"u_specularGlossinessTexture",d,oe,pe),se=p(e,"u_diffuseTexture",d,oe,pe),le=p(e,"u_metallicRoughnessTexture",d,oe,pe),ce=p(e,"u_occlusionTexture",d,oe,pe),de=p(e,"u_emissiveTexture",d,oe,pe),ue=pe.fragmentShaderMain}M&&(Q.a_joint={semantic:"JOINTS_0"},Q.a_weight={semantic:"WEIGHTS_0"},A+="attribute vec4 a_joint;\n",A+="attribute vec4 a_weight;\n"),N&&(Q.a_vertexColor={semantic:"COLOR_0"},A+="attribute vec4 a_vertexColor;\n",A+="varying vec4 v_vertexColor;\n",Z+="  v_vertexColor = a_vertexColor;\n",z+="varying vec4 v_vertexColor;\n"),b&&(Q.a_batchId={semantic:"_BATCHID"},A+="attribute float a_batchId;\n"),A+="void main(void) \n{\n",A+=Z,A+="}\n",G&&!U&&(z+="const float M_PI = 3.141592653589793;\n",z+="vec3 lambertianDiffuse(vec3 diffuseColor) \n{\n    return diffuseColor / M_PI;\n}\n\n",z+="vec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH) \n{\n    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\n",z+="vec3 fresnelSchlick(float metalness, float VdotH) \n{\n    return metalness + (vec3(1.0) - metalness) * pow(1.0 - VdotH, 5.0);\n}\n\n",z+="float smithVisibilityG1(float NdotV, float roughness) \n{\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\n",z+="float smithVisibilityGGX(float roughness, float NdotL, float NdotV) \n{\n    return smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness);\n}\n\n",z+="float GGX(float roughness, float NdotH) \n{\n    float roughnessSquared = roughness * roughness;\n    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n    return roughnessSquared / (M_PI * f * f);\n}\n\n"),z+="vec3 SRGBtoLINEAR3(vec3 srgbIn) \n{\n    return pow(srgbIn, vec3(2.2));\n}\n\n",z+="vec4 SRGBtoLINEAR4(vec4 srgbIn) \n{\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\n    return vec4(linearOut, srgbIn.a);\n}\n\n",z+="vec3 applyTonemapping(vec3 linearIn) \n{\n#ifndef HDR \n    return czm_acesTonemapping(linearIn);\n#else \n    return linearIn;\n#endif \n}\n\n",z+="vec3 LINEARtoSRGB(vec3 linearIn) \n{\n#ifndef HDR \n    return pow(linearIn, vec3(1.0/2.2));\n#else \n    return linearIn;\n#endif \n}\n\n",z+="vec2 computeTexCoord(vec2 texCoords, vec2 offset, float rotation, vec2 scale) \n{\n    rotation = -rotation; \n    mat3 transform = mat3(\n        cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0, \n       -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0, \n        offset.x, offset.y, 1.0); \n    vec2 transformedTexCoords = (transform * vec3(fract(texCoords), 1.0)).xy; \n    return transformedTexCoords; \n}\n\n",z+="#ifdef USE_IBL_LIGHTING \n",z+="uniform vec2 gltf_iblFactor; \n",z+="#endif \n",z+="#ifdef USE_CUSTOM_LIGHT_COLOR \n",z+="uniform vec3 gltf_lightColor; \n",z+="#endif \n",z+="void main(void) \n{\n",z+=ue,G&&!U&&(z+="    vec3 ng = normalize(v_normal);\n",z+="    vec3 positionWC = vec3(czm_inverseView * vec4(v_positionEC, 1.0));\n",Object(i["a"])(d.u_normalTexture)?V?(z+="    vec3 t = normalize(v_tangent.xyz);\n",z+="    vec3 b = normalize(cross(ng, t) * v_tangent.w);\n",z+="    mat3 tbn = mat3(t, b, ng);\n",z+="    vec3 n = texture2D(u_normalTexture, "+ie+").rgb;\n",z+="    n = normalize(tbn * (2.0 * n - 1.0));\n"):(z="#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"+z,z+="#ifdef GL_OES_standard_derivatives\n",z+="    vec3 pos_dx = dFdx(v_positionEC);\n",z+="    vec3 pos_dy = dFdy(v_positionEC);\n",z+="    vec3 tex_dx = dFdx(vec3("+ie+",0.0));\n",z+="    vec3 tex_dy = dFdy(vec3("+ie+",0.0));\n",z+="    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n",z+="    t = normalize(t - ng * dot(ng, t));\n",z+="    vec3 b = normalize(cross(ng, t));\n",z+="    mat3 tbn = mat3(t, b, ng);\n",z+="    vec3 n = texture2D(u_normalTexture, "+ie+").rgb;\n",z+="    n = normalize(tbn * (2.0 * n - 1.0));\n",z+="#else\n",z+="    vec3 n = ng;\n",z+="#endif\n"):z+="    vec3 n = ng;\n",n.doubleSided&&(z+="    if (czm_backFacing())\n",z+="    {\n",z+="        n = -n;\n",z+="    }\n")),Object(i["a"])(d.u_baseColorTexture)?(z+="    vec4 baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, "+ae+"));\n",Object(i["a"])(d.u_baseColorFactor)&&(z+="    baseColorWithAlpha *= u_baseColorFactor;\n")):Object(i["a"])(d.u_baseColorFactor)?z+="    vec4 baseColorWithAlpha = u_baseColorFactor;\n":z+="    vec4 baseColorWithAlpha = vec4(1.0);\n",N&&(z+="    baseColorWithAlpha *= v_vertexColor;\n"),z+="    vec3 baseColor = baseColorWithAlpha.rgb;\n",G&&!U?(O?(Object(i["a"])(d.u_specularGlossinessTexture)?(z+="    vec4 specularGlossiness = SRGBtoLINEAR4(texture2D(u_specularGlossinessTexture, "+re+"));\n",z+="    vec3 specular = specularGlossiness.rgb;\n",z+="    float glossiness = specularGlossiness.a;\n",Object(i["a"])(d.u_specularFactor)&&(z+="    specular *= u_specularFactor;\n"),Object(i["a"])(d.u_glossinessFactor)&&(z+="    glossiness *= u_glossinessFactor;\n")):(Object(i["a"])(d.u_specularFactor)?z+="    vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0));\n":z+="    vec3 specular = vec3(1.0);\n",Object(i["a"])(d.u_glossinessFactor)?z+="    float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\n":z+="    float glossiness = 1.0;\n"),Object(i["a"])(d.u_diffuseTexture)?(z+="    vec4 diffuse = SRGBtoLINEAR4(texture2D(u_diffuseTexture, "+se+"));\n",Object(i["a"])(d.u_diffuseFactor)&&(z+="    diffuse *= u_diffuseFactor;\n")):Object(i["a"])(d.u_diffuseFactor)?z+="    vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\n":z+="    vec4 diffuse = vec4(1.0);\n"):Object(i["a"])(d.u_metallicRoughnessTexture)?(z+="    vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, "+le+").rgb;\n",z+="    float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\n",z+="    float roughness = clamp(metallicRoughness.g, 0.04, 1.0);\n",Object(i["a"])(d.u_metallicFactor)&&(z+="    metalness *= u_metallicFactor;\n"),Object(i["a"])(d.u_roughnessFactor)&&(z+="    roughness *= u_roughnessFactor;\n")):(Object(i["a"])(d.u_metallicFactor)?z+="    float metalness = clamp(u_metallicFactor, 0.0, 1.0);\n":z+="    float metalness = 1.0;\n",Object(i["a"])(d.u_roughnessFactor)?z+="    float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\n":z+="    float roughness = 1.0;\n"),z+="    vec3 v = -normalize(v_positionEC);\n",z+="#ifndef USE_CUSTOM_LIGHT_COLOR \n",z+="    vec3 lightColorHdr = czm_lightColorHdr;\n",z+="#else \n",z+="    vec3 lightColorHdr = gltf_lightColor;\n",z+="#endif \n",z+="    vec3 l = normalize(czm_lightDirectionEC);\n",z+="    vec3 h = normalize(v + l);\n",z+="    float NdotL = clamp(dot(n, l), 0.001, 1.0);\n",z+="    float NdotV = abs(dot(n, v)) + 0.001;\n",z+="    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n",z+="    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n",z+="    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n",z+="    vec3 f0 = vec3(0.04);\n",O?(z+="    float roughness = 1.0 - glossiness;\n",z+="    vec3 diffuseColor = diffuse.rgb * (1.0 - max(max(specular.r, specular.g), specular.b));\n",z+="    vec3 specularColor = specular;\n"):(z+="    vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\n",z+="    vec3 specularColor = mix(f0, baseColor, metalness);\n"),z+="    float alpha = roughness * roughness;\n",z+="    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n",z+="    vec3 r90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\n",z+="    vec3 r0 = specularColor.rgb;\n",z+="    vec3 F = fresnelSchlick2(r0, r90, VdotH);\n",z+="    float G = smithVisibilityGGX(alpha, NdotL, NdotV);\n",z+="    float D = GGX(alpha, NdotH);\n",z+="    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\n",z+="    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\n",z+="    vec3 color = NdotL * lightColorHdr * (diffuseContribution + specularContribution);\n",z+="#if defined(USE_IBL_LIGHTING) && !defined(DIFFUSE_IBL) && !defined(SPECULAR_IBL) \n",z+="    vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\n",z+="    float vertexRadius = length(positionWC);\n",z+="    float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius);\n",z+="    float reflectionDotNadir = dot(r, normalize(positionWC));\n",z+="    r.x = -r.x;\n",z+="    r = -normalize(czm_temeToPseudoFixed * r);\n",z+="    r.x = -r.x;\n",z+="    float inverseRoughness = 1.04 - roughness;\n",z+="    inverseRoughness *= inverseRoughness;\n",z+="    vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\n",z+="    float atmosphereHeight = 0.05;\n",z+="    float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\n",z+="    float blendRegionOffset = roughness * -1.0;\n",z+="    float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\n",z+="    float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\n",z+="    float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\n",z+="    float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\n",z+="    vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\n",z+="    vec3 nadirColor = belowHorizonColor * 0.5;\n",z+="    vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\n",z+="    vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\n",z+="    vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\n",z+="    vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\n",z+="    float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\n",z+="    float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\n",z+="    vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\n",z+="    float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\n",z+="    vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\n",z+="    specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\n",z+="    specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\n",z+="#ifdef USE_SUN_LUMINANCE \n",z+="    float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * l), normalize(positionWC * -1.0)), 0.001, 1.0);\n",z+="    float S = acos(LdotZenith);\n",z+="    float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\n",z+="    float gamma = acos(NdotL);\n",z+="    float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(NdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\n",z+="    float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));\n",z+="    float luminance = gltf_luminanceAtZenith * (numerator / denominator);\n",z+="#endif \n",z+="    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\n",z+="    vec3 IBLColor = (diffuseIrradiance * diffuseColor * gltf_iblFactor.x) + (specularIrradiance * SRGBtoLINEAR3(specularColor * brdfLut.x + brdfLut.y) * gltf_iblFactor.y);\n",z+="    float maximumComponent = max(max(lightColorHdr.x, lightColorHdr.y), lightColorHdr.z);\n",z+="    vec3 lightColor = lightColorHdr / max(maximumComponent, 1.0);\n",z+="    IBLColor *= lightColor;\n",z+="#ifdef USE_SUN_LUMINANCE \n",z+="    color += IBLColor * luminance;\n",z+="#else \n",z+="    color += IBLColor; \n",z+="#endif \n",z+="#elif defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) \n",z+="    const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0); \n",z+="    vec3 cubeDir = normalize(yUpToZUp * gltf_iblReferenceFrameMatrix * normalize(reflect(-v, n))); \n",z+="#ifdef DIFFUSE_IBL \n",z+="#ifdef CUSTOM_SPHERICAL_HARMONICS \n",z+="    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, gltf_sphericalHarmonicCoefficients); \n",z+="#else \n",z+="    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); \n",z+="#endif \n",z+="#else \n",z+="    vec3 diffuseIrradiance = vec3(0.0); \n",z+="#endif \n",z+="#ifdef SPECULAR_IBL \n",z+="    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\n",z+="#ifdef CUSTOM_SPECULAR_IBL \n",z+="    vec3 specularIBL = czm_sampleOctahedralProjection(gltf_specularMap, gltf_specularMapSize, cubeDir,  roughness * gltf_maxSpecularLOD, gltf_maxSpecularLOD);\n",z+="#else \n",z+="    vec3 specularIBL = czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir,  roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);\n",z+="#endif \n",z+="    specularIBL *= F * brdfLut.x + brdfLut.y;\n",z+="#else \n",z+="    vec3 specularIBL = vec3(0.0); \n",z+="#endif \n",z+="    color += diffuseIrradiance * diffuseColor + specularColor * specularIBL;\n",z+="#endif \n"):z+="    vec3 color = baseColor;\n",U||(Object(i["a"])(d.u_occlusionTexture)&&(z+="    color *= texture2D(u_occlusionTexture, "+ce+").r;\n"),Object(i["a"])(d.u_emissiveTexture)?(z+="    vec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, "+de+").rgb);\n",Object(i["a"])(d.u_emissiveFactor)&&(z+="    emissive *= u_emissiveFactor;\n"),z+="    color += emissive;\n"):Object(i["a"])(d.u_emissiveFactor)&&(z+="    color += u_emissiveFactor;\n")),U||(z+="    color = applyTonemapping(color);\n"),z+="    color = LINEARtoSRGB(color);\n",k&&(z+="    float outlineness = max(\n",z+="        texture2D(u_outlineTexture, vec2(v_outlineCoordinates.x, 0.5)).r,\n",z+="        max(\n",z+="          texture2D(u_outlineTexture, vec2(v_outlineCoordinates.y, 0.5)).r,\n",z+="          texture2D(u_outlineTexture, vec2(v_outlineCoordinates.z, 0.5)).r));\n",z+="    color = mix(color, vec3(0.0, 0.0, 0.0), outlineness);\n"),Object(i["a"])(K)?"MASK"===K?(z+="    if (baseColorWithAlpha.a < u_alphaCutoff) {\n",z+="        discard;\n",z+="    }\n",z+="    gl_FragColor = vec4(color, 1.0);\n"):z+="BLEND"===K?"    gl_FragColor = vec4(color, baseColorWithAlpha.a);\n":"    gl_FragColor = vec4(color, 1.0);\n":z+="    gl_FragColor = vec4(color, 1.0);\n",z+="}\n";var fe=Object(s["a"])(E,{type:a["a"].VERTEX_SHADER,extras:{_pipeline:{source:A,extension:".glsl"}}}),ve=Object(s["a"])(E,{type:a["a"].FRAGMENT_SHADER,extras:{_pipeline:{source:z,extension:".glsl"}}}),_e=Object(s["a"])(y,{fragmentShader:ve,vertexShader:fe}),ge=Object(s["a"])(x,{attributes:Q,program:_e,uniforms:q});return ge}function C(e){if(-1!==e.indexOf("Offset"))return a["a"].FLOAT_VEC2;if(-1!==e.indexOf("Rotation"))return a["a"].FLOAT;if(-1!==e.indexOf("Scale"))return a["a"].FLOAT_VEC2;if(-1!==e.indexOf("Texture"))return a["a"].SAMPLER_2D;switch(e){case"u_baseColorFactor":return a["a"].FLOAT_VEC4;case"u_metallicFactor":return a["a"].FLOAT;case"u_roughnessFactor":return a["a"].FLOAT;case"u_emissiveFactor":return a["a"].FLOAT_VEC3;case"u_diffuseFactor":return a["a"].FLOAT_VEC4;case"u_specularFactor":return a["a"].FLOAT_VEC3;case"u_glossinessFactor":return a["a"].FLOAT}}n["a"]=u},d3d4:function(e,n,t){"use strict";n["a"]="#ifdef INSTANCED\nattribute vec2 direction;\n#endif\nattribute vec4 positionHighAndScale;\nattribute vec4 positionLowAndRotation;\nattribute vec4 compressedAttribute0;                       // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates (texture offset)\nattribute vec4 compressedAttribute1;                       // aligned axis, translucency by distance, image width\nattribute vec4 compressedAttribute2;                       // label horizontal origin, image height, color, pick color, size in meters, valid aligned axis, 13 bits free\nattribute vec4 eyeOffset;                                  // eye offset in meters, 4 bytes free (texture range)\nattribute vec4 scaleByDistance;                            // near, nearScale, far, farScale\nattribute vec4 pixelOffsetScaleByDistance;                 // near, nearScale, far, farScale\nattribute vec4 compressedAttribute3;                       // distance display condition near, far, disableDepthTestDistance, dimensions\nattribute vec2 sdf;                                        // sdf outline color (rgb) and width (w)\n#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)\nattribute vec4 textureCoordinateBoundsOrLabelTranslate;    // the min and max x and y values for the texture coordinates\n#endif\n#ifdef VECTOR_TILE\nattribute float a_batchId;\n#endif\n\nvarying vec2 v_textureCoordinates;\n#ifdef FRAGMENT_DEPTH_CHECK\nvarying vec4 v_textureCoordinateBounds;\nvarying vec4 v_originTextureCoordinateAndTranslate;\nvarying vec4 v_compressed;                                 // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize\nvarying mat2 v_rotationMatrix;\n#endif\n\nvarying vec4 v_pickColor;\nvarying vec4 v_color;\n#ifdef SDF\nvarying vec4 v_outlineColor;\nvarying float v_outlineWidth;\n#endif\n\nconst float UPPER_BOUND = 32768.0;\n\nconst float SHIFT_LEFT16 = 65536.0;\nconst float SHIFT_LEFT12 = 4096.0;\nconst float SHIFT_LEFT8 = 256.0;\nconst float SHIFT_LEFT7 = 128.0;\nconst float SHIFT_LEFT5 = 32.0;\nconst float SHIFT_LEFT3 = 8.0;\nconst float SHIFT_LEFT2 = 4.0;\nconst float SHIFT_LEFT1 = 2.0;\n\nconst float SHIFT_RIGHT12 = 1.0 / 4096.0;\nconst float SHIFT_RIGHT8 = 1.0 / 256.0;\nconst float SHIFT_RIGHT7 = 1.0 / 128.0;\nconst float SHIFT_RIGHT5 = 1.0 / 32.0;\nconst float SHIFT_RIGHT3 = 1.0 / 8.0;\nconst float SHIFT_RIGHT2 = 1.0 / 4.0;\nconst float SHIFT_RIGHT1 = 1.0 / 2.0;\n\nvec4 addScreenSpaceOffset(vec4 positionEC, vec2 imageSize, float scale, vec2 direction, vec2 origin, vec2 translate, vec2 pixelOffset, vec3 alignedAxis, bool validAlignedAxis, float rotation, bool sizeInMeters, out mat2 rotationMatrix, out float mpp)\n{\n    // Note the halfSize cannot be computed in JavaScript because it is sent via\n    // compressed vertex attributes that coerce it to an integer.\n    vec2 halfSize = imageSize * scale * 0.5;\n    halfSize *= ((direction * 2.0) - 1.0);\n\n    vec2 originTranslate = origin * abs(halfSize);\n\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    if (validAlignedAxis || rotation != 0.0)\n    {\n        float angle = rotation;\n        if (validAlignedAxis)\n        {\n            vec4 projectedAlignedAxis = czm_modelViewProjection * vec4(alignedAxis, 0.0);\n            angle += sign(-projectedAlignedAxis.x) * acos(sign(projectedAlignedAxis.y) * (projectedAlignedAxis.y * projectedAlignedAxis.y) /\n                    (projectedAlignedAxis.x * projectedAlignedAxis.x + projectedAlignedAxis.y * projectedAlignedAxis.y));\n        }\n\n        float cosTheta = cos(angle);\n        float sinTheta = sin(angle);\n        rotationMatrix = mat2(cosTheta, sinTheta, -sinTheta, cosTheta);\n        halfSize = rotationMatrix * halfSize;\n    }\n    else\n    {\n        rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);\n    }\n#endif\n\n    mpp = czm_metersPerPixel(positionEC);\n    positionEC.xy += (originTranslate + halfSize) * czm_branchFreeTernary(sizeInMeters, 1.0, mpp);\n    positionEC.xy += (translate + pixelOffset) * mpp;\n\n    return positionEC;\n}\n\n#ifdef VERTEX_DEPTH_CHECK\nfloat getGlobeDepth(vec4 positionEC)\n{\n    vec4 posWC = czm_eyeToWindowCoordinates(positionEC);\n\n    float globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, posWC.xy / czm_viewport.zw));\n\n    if (globeDepth == 0.0)\n    {\n        return 0.0; // not on the globe\n    }\n\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(posWC.xy, globeDepth);\n    return eyeCoordinate.z / eyeCoordinate.w;\n}\n#endif\nvoid main()\n{\n    // Modifying this shader may also require modifications to Billboard._computeScreenSpacePosition\n\n    // unpack attributes\n    vec3 positionHigh = positionHighAndScale.xyz;\n    vec3 positionLow = positionLowAndRotation.xyz;\n    float scale = positionHighAndScale.w;\n\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    float rotation = positionLowAndRotation.w;\n#else\n    float rotation = 0.0;\n#endif\n\n    float compressed = compressedAttribute0.x;\n\n    vec2 pixelOffset;\n    pixelOffset.x = floor(compressed * SHIFT_RIGHT7);\n    compressed -= pixelOffset.x * SHIFT_LEFT7;\n    pixelOffset.x -= UPPER_BOUND;\n\n    vec2 origin;\n    origin.x = floor(compressed * SHIFT_RIGHT5);\n    compressed -= origin.x * SHIFT_LEFT5;\n\n    origin.y = floor(compressed * SHIFT_RIGHT3);\n    compressed -= origin.y * SHIFT_LEFT3;\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    vec2 depthOrigin = origin.xy;\n#endif\n    origin -= vec2(1.0);\n\n    float show = floor(compressed * SHIFT_RIGHT2);\n    compressed -= show * SHIFT_LEFT2;\n\n#ifdef INSTANCED\n    vec2 textureCoordinatesBottomLeft = czm_decompressTextureCoordinates(compressedAttribute0.w);\n    vec2 textureCoordinatesRange = czm_decompressTextureCoordinates(eyeOffset.w);\n    vec2 textureCoordinates = textureCoordinatesBottomLeft + direction * textureCoordinatesRange;\n#else\n    vec2 direction;\n    direction.x = floor(compressed * SHIFT_RIGHT1);\n    direction.y = compressed - direction.x * SHIFT_LEFT1;\n\n    vec2 textureCoordinates = czm_decompressTextureCoordinates(compressedAttribute0.w);\n#endif\n\n    float temp = compressedAttribute0.y  * SHIFT_RIGHT8;\n    pixelOffset.y = -(floor(temp) - UPPER_BOUND);\n\n    vec2 translate;\n    translate.y = (temp - floor(temp)) * SHIFT_LEFT16;\n\n    temp = compressedAttribute0.z * SHIFT_RIGHT8;\n    translate.x = floor(temp) - UPPER_BOUND;\n\n    translate.y += (temp - floor(temp)) * SHIFT_LEFT8;\n    translate.y -= UPPER_BOUND;\n\n    temp = compressedAttribute1.x * SHIFT_RIGHT8;\n    float temp2 = floor(compressedAttribute2.w * SHIFT_RIGHT2);\n\n    vec2 imageSize = vec2(floor(temp), temp2);\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    float labelHorizontalOrigin = floor(compressedAttribute2.w - (temp2 * SHIFT_LEFT2));\n    float applyTranslate = 0.0;\n    if (labelHorizontalOrigin != 0.0) // is a billboard, so set apply translate to false\n    {\n        applyTranslate = 1.0;\n        labelHorizontalOrigin -= 2.0;\n        depthOrigin.x = labelHorizontalOrigin + 1.0;\n    }\n\n    depthOrigin = vec2(1.0) - (depthOrigin * 0.5);\n#endif\n\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    vec4 translucencyByDistance;\n    translucencyByDistance.x = compressedAttribute1.z;\n    translucencyByDistance.z = compressedAttribute1.w;\n\n    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n\n    temp = compressedAttribute1.y * SHIFT_RIGHT8;\n    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n#endif\n\n#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)\n    temp = compressedAttribute3.w;\n    temp = temp * SHIFT_RIGHT12;\n\n    vec2 dimensions;\n    dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;\n    dimensions.x = floor(temp);\n#endif\n\n#ifdef ALIGNED_AXIS\n    vec3 alignedAxis = czm_octDecode(floor(compressedAttribute1.y * SHIFT_RIGHT8));\n    temp = compressedAttribute2.z * SHIFT_RIGHT5;\n    bool validAlignedAxis = (temp - floor(temp)) * SHIFT_LEFT1 > 0.0;\n#else\n    vec3 alignedAxis = vec3(0.0);\n    bool validAlignedAxis = false;\n#endif\n\n    vec4 pickColor;\n    vec4 color;\n\n    temp = compressedAttribute2.y;\n    temp = temp * SHIFT_RIGHT8;\n    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    pickColor.r = floor(temp);\n\n    temp = compressedAttribute2.x;\n    temp = temp * SHIFT_RIGHT8;\n    color.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    color.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    color.r = floor(temp);\n\n    temp = compressedAttribute2.z * SHIFT_RIGHT8;\n    bool sizeInMeters = floor((temp - floor(temp)) * SHIFT_LEFT7) > 0.0;\n    temp = floor(temp) * SHIFT_RIGHT8;\n\n    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;\n    pickColor /= 255.0;\n\n    color.a = floor(temp);\n    color /= 255.0;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\n\n#if defined(FRAGMENT_DEPTH_CHECK) || defined(VERTEX_DEPTH_CHECK)\n    float eyeDepth = positionEC.z;\n#endif\n\n    positionEC = czm_eyeOffset(positionEC, eyeOffset.xyz);\n    positionEC.xyz *= show;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(EYE_DISTANCE_PIXEL_OFFSET) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)\n    float lengthSq;\n    if (czm_sceneMode == czm_sceneMode2D)\n    {\n        // 2D camera distance is a special case\n        // treat all billboards as flattened to the z=0.0 plane\n        lengthSq = czm_eyeHeight2D.y;\n    }\n    else\n    {\n        lengthSq = dot(positionEC.xyz, positionEC.xyz);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_SCALING\n    float distanceScale = czm_nearFarScalar(scaleByDistance, lengthSq);\n    scale *= distanceScale;\n    translate *= distanceScale;\n    // push vertex behind near plane for clipping\n    if (scale == 0.0)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n    float translucency = 1.0;\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);\n    // push vertex behind near plane for clipping\n    if (translucency == 0.0)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_PIXEL_OFFSET\n    float pixelOffsetScale = czm_nearFarScalar(pixelOffsetScaleByDistance, lengthSq);\n    pixelOffset *= pixelOffsetScale;\n#endif\n\n#ifdef DISTANCE_DISPLAY_CONDITION\n    float nearSq = compressedAttribute3.x;\n    float farSq = compressedAttribute3.y;\n    if (lengthSq < nearSq || lengthSq > farSq)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n    mat2 rotationMatrix;\n    float mpp;\n\n#ifdef DISABLE_DEPTH_DISTANCE\n    float disableDepthTestDistance = compressedAttribute3.z;\n#endif\n\n#ifdef VERTEX_DEPTH_CHECK\nif (lengthSq < disableDepthTestDistance) {\n    float depthsilon = 10.0;\n\n    vec2 labelTranslate = textureCoordinateBoundsOrLabelTranslate.xy;\n    vec4 pEC1 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n    float globeDepth1 = getGlobeDepth(pEC1);\n\n    if (globeDepth1 != 0.0 && pEC1.z + depthsilon < globeDepth1)\n    {\n        vec4 pEC2 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0, 1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n        float globeDepth2 = getGlobeDepth(pEC2);\n\n        if (globeDepth2 != 0.0 && pEC2.z + depthsilon < globeDepth2)\n        {\n            vec4 pEC3 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n            float globeDepth3 = getGlobeDepth(pEC3);\n            if (globeDepth3 != 0.0 && pEC3.z + depthsilon < globeDepth3)\n            {\n                positionEC.xyz = vec3(0.0);\n            }\n        }\n    }\n}\n#endif\n\n    positionEC = addScreenSpaceOffset(positionEC, imageSize, scale, direction, origin, translate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n    gl_Position = czm_projection * positionEC;\n    v_textureCoordinates = textureCoordinates;\n\n#ifdef LOG_DEPTH\n    czm_vertexLogDepth();\n#endif\n\n#ifdef DISABLE_DEPTH_DISTANCE\n    if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)\n    {\n        disableDepthTestDistance = czm_minimumDisableDepthTestDistance;\n    }\n\n    if (disableDepthTestDistance != 0.0)\n    {\n        // Don't try to \"multiply both sides\" by w.  Greater/less-than comparisons won't work for negative values of w.\n        float zclip = gl_Position.z / gl_Position.w;\n        bool clipped = (zclip < -1.0 || zclip > 1.0);\n        if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))\n        {\n            // Position z on the near plane.\n            gl_Position.z = -gl_Position.w;\n#ifdef LOG_DEPTH\n            v_depthFromNearPlusOne = 1.0;\n#endif\n        }\n    }\n#endif\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    if (sizeInMeters) {\n        translate /= mpp;\n        dimensions /= mpp;\n        imageSize /= mpp;\n    }\n\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    v_rotationMatrix = rotationMatrix;\n#else\n    v_rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);\n#endif\n\n    float enableDepthCheck = 0.0;\n    if (lengthSq < disableDepthTestDistance)\n    {\n        enableDepthCheck = 1.0;\n    }\n\n    float dw = floor(clamp(dimensions.x, 0.0, SHIFT_LEFT12));\n    float dh = floor(clamp(dimensions.y, 0.0, SHIFT_LEFT12));\n\n    float iw = floor(clamp(imageSize.x, 0.0, SHIFT_LEFT12));\n    float ih = floor(clamp(imageSize.y, 0.0, SHIFT_LEFT12));\n\n    v_compressed.x = eyeDepth;\n    v_compressed.y = applyTranslate * SHIFT_LEFT1 + enableDepthCheck;\n    v_compressed.z = dw * SHIFT_LEFT12 + dh;\n    v_compressed.w = iw * SHIFT_LEFT12 + ih;\n    v_originTextureCoordinateAndTranslate.xy = depthOrigin;\n    v_originTextureCoordinateAndTranslate.zw = translate;\n    v_textureCoordinateBounds = textureCoordinateBoundsOrLabelTranslate;\n\n#endif\n\n#ifdef SDF\n    vec4 outlineColor;\n    float outlineWidth;\n\n    temp = sdf.x;\n    temp = temp * SHIFT_RIGHT8;\n    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    outlineColor.r = floor(temp);\n\n    temp = sdf.y;\n    temp = temp * SHIFT_RIGHT8;\n    float temp3 = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    outlineWidth = (temp - floor(temp)) * SHIFT_LEFT8;\n    outlineColor.a = floor(temp);\n    outlineColor /= 255.0;\n\n    v_outlineWidth = outlineWidth / 255.0;\n    v_outlineColor = outlineColor;\n    v_outlineColor.a *= translucency;\n#endif\n\n    v_pickColor = pickColor;\n\n    v_color = color;\n    v_color.a *= translucency;\n\n}\n"},d3f9:function(e,n,t){"use strict";n["a"]="varying vec4 v_color;\n\nvoid main()\n{\n    gl_FragColor = czm_gammaCorrect(v_color);\n}\n"},e64a:function(e,n,t){"use strict";n["a"]="varying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n\n    vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    materialInput.s = v_st.s;\n    materialInput.st = v_st;\n    materialInput.str = vec3(v_st, 0.0);\n\n    // Convert tangent space material normal to eye space\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\n    // Convert view vector to world space\n    vec3 positionToEyeEC = -v_positionEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n#endif\n}\n"},f533:function(e,n,t){"use strict";n["a"]="varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    vec4 color = czm_gammaCorrect(v_color);\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n}\n"},f74b:function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionMC = position3DHigh + position3DLow;           // position in model coordinates\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates\n    v_st = st;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"}}]);